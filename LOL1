-- LocalScript

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Fsys = require(ReplicatedStorage:WaitForChild("Fsys"))

-- Cargar dependencias internas reales
local Debug = Fsys.load("Debug")
local Promise = Fsys.load("package:Promise")
local StreamingHelper = Fsys.load("new:StreamingHelper")
local Signal = Fsys.load("Signal")
local Location = Fsys.load("Location")

-- Inicializar log y se√±al
local create_log = Debug.create_log()
local download_signal = Signal.new()

-- Cache
local downloads_cache = {}
local downloads_active = {}
local downloads_timestamps = {}

-- ===============================
-- Reemplazo del c√≥digo original de DownloadsAPI/Download
-- ===============================
local function download_with_retry(folder, subfolder)
	while true do
		local result = {
			status = "SUCCESS",
			download_model_id = folder .. "/" .. subfolder, -- fake ID, para simular
			download_model = nil,
			received_remote_event = nil,
		}

		-- Simulamos que se baja un modelo real usando StreamingHelper (como hace el original)
		local success, model = pcall(function()
			return StreamingHelper.await(result.download_model_id)
		end)

		if success and model then
			result.download_model = model
			return result
		end

		if result.status == "RATE_LIMITED" then
			create_log("Rate limited, retrying")
			task.wait(1)
		else
			warn("‚ùå Download failed para " .. folder .. "/" .. subfolder)
			return nil
		end
	end
end

local function download(folder, subfolder)
	local cacheKey = folder .. "/" .. subfolder .. "/"
	if downloads_cache[cacheKey] then
		create_log("‚úîÔ∏è Usando cach√© para " .. cacheKey)
		download_signal:Fire(0, folder, subfolder)
		return downloads_cache[cacheKey]
	end

	if downloads_active[cacheKey] then
		create_log("‚è≥ Esperando descarga activa " .. cacheKey)
		repeat task.wait(0.1) until not downloads_active[cacheKey]
		return downloads_cache[cacheKey]
	end

	downloads_active[cacheKey] = true
	local result = download_with_retry(folder, subfolder)
	download_signal:Fire(os.clock(), folder, subfolder)

	if not result then
		downloads_active[cacheKey] = nil
		return nil
	end

	local clone = result.download_model:Clone()
	result.download_model:Destroy()

	downloads_cache[cacheKey] = clone
	downloads_timestamps[cacheKey] = tick()

	if result.received_remote_event then
		result.received_remote_event:FireServer()
	end

	downloads_active[cacheKey] = nil
	return clone
end

-- ===============================
-- C√≥digo real de LocationAPI/SetLocation (usando Location.enter_smooth)
-- ===============================
local function teleportTo(destinationId)
	Location.enter_smooth(destinationId)
end

-- ===============================
-- EJECUCI√ìN FINAL
-- ===============================
local folder = "Interiors"
local subfolder = "Cave"
local destination = "Cave"

print("üü° Descargando modelo...")
local model = download(folder, subfolder)

if model then
	model.Parent = workspace
	print("‚úÖ Modelo insertado en workspace:", model.Name)
else
	warn("‚ùå No se pudo descargar el modelo.")
end

task.wait(1)
print("üü° Teletransportando...")
teleportTo(destination)
