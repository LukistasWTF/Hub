--[[ 
AutoMinigames – TP por coordenadas + Smart ETA + AutoPlay (v4.6)
Requisitos: LocalScript (cliente)

✅ Mira ETA real de joetation / coconut_bonk
✅ Teleporta por COORDENADAS al minijuego con ETA más corta
✅ Juega automáticamente y, al terminar, vuelve a elegir y teleporta
✅ UI mínima para ver/editar coordenadas + botones de TP manual
✅ Sin InteriorsM / sin UIManager / sin RouterClient

NOTA: por petición, NO enviamos join_queue explícito (el juego te mete al estar en la zona).
Si lo quisieras, cambia CONFIG.sendJoinMessageAfterTP = true
]]]

------------------ Servicios / Cliente ------------------
local Players = game:GetService("Players")
local RS      = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then return end
if not RunService:IsClient() then warn("[AutoMG] Debe ser LocalScript."); return end

------------------ Loader seguro (Fsys) ------------------
local function isMS(x) return typeof(x)=="Instance" and x:IsA("ModuleScript") end
local function srequire(ms) if not isMS(ms) then return nil end local ok,r=pcall(function() return require(ms) end); return ok and r or nil end
local Fsys = srequire(RS:FindFirstChild("Fsys"))
local FSYS_LOAD = (Fsys and type(Fsys.load)=="function") and Fsys.load or nil
local function loadM(name)
	if FSYS_LOAD then local ok,mod=pcall(function() return FSYS_LOAD(name) end); if ok and mod then return mod end end
	for _,root in ipairs({"ClientModules","SharedModules"}) do
		local f = RS:FindFirstChild(root, true)
		if f then local m=f:FindFirstChild(name, true); local got=srequire(m); if got then return got end end
	end
	return nil
end

------------------ Módulos que usamos ------------------
local LiveOpsTime           = loadM("LiveOpsTime") or { now=function() return os.clock() end }
local MinigameClientManager = loadM("MinigameClientManager")
local ClientData            = loadM("ClientData") -- opcional

------------------ Config ------------------
local CONFIG = {
	autoEnabled = true,         -- AUTO ON al iniciar
	statusRefresh = 1.0,        -- s
	defaultQueueCountdown = 12, -- fallback ETA
	inProgressGrace = 5,        -- s

	-- Coordenadas INICIALES (puedes cambiarlas en la UI)
	coords = {
		coconut_bonk = Vector3.new(-600.3, 41.6, -1610.3),
		joetation    = Vector3.new(-590.8, 35.8, -1667.1),
	},

	-- ¿Enviar join después de TP? (lo pediste OFF)
	sendJoinMessageAfterTP = false,

	-- Auto‑play (cadencia adaptativa)
	actionCadence = { joetation = 1.25, coconut_bonk = 1.50 },
	minCadence = 0.6, maxCadence = 2.5, cadenceStepDown = 0.10, cadenceStepUp = 0.15,

	-- Anti‑AFK
	enableAFK = true,
}

------------------ Utils / Logs ------------------
local function toast(t) pcall(function() StarterGui:SetCore("SendNotification", {Title="AutoMG", Text=t, Duration=2}) end) end
local function fmtTime(s) s = math.max(0, math.floor(s)); return string.format("%02d:%02d", math.floor(s/60), s%60) end
local function hrp() local c=LocalPlayer.Character; return c and c:FindFirstChild("HumanoidRootPart") end
local function humanoid() local c=LocalPlayer.Character; return c and c:FindFirstChildWhichIsA("Humanoid") end
local function srvNow() if workspace.GetServerTimeNow then return workspace:GetServerTimeNow() end return LiveOpsTime.now() end

------------------ UI mínima (editar coords + TP manual + Auto ON/OFF) ------------------
local UI = {}
do
	local gui = Instance.new("ScreenGui")
	gui.Name = "AutoMG_UI"
	gui.ResetOnSpawn = false
	gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0, 350, 0, 160)
	frame.Position = UDim2.new(0, 10, 0, 10)
	frame.BackgroundTransparency = 0.2
	frame.BackgroundColor3 = Color3.fromRGB(18,18,24)
	frame.Parent = gui
	Instance.new("UICorner", frame).CornerRadius=UDim.new(0,10)

	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1,-10,0,22)
	title.Position = UDim2.new(0, 10, 0, 8)
	title.BackgroundTransparency = 1
	title.Font = Enum.Font.GothamBold
	title.TextSize = 18
	title.TextColor3 = Color3.fromRGB(255,255,255)
	title.Text = "AutoMG v4.6 – TP coords + Auto"
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = frame

	local function coordRow(y, label, id)
		local lab = Instance.new("TextLabel")
		lab.Size = UDim2.new(0, 95, 0, 22)
		lab.Position = UDim2.new(0, 10, 0, y)
		lab.BackgroundTransparency = 1
		lab.Font = Enum.Font.Gotham
		lab.TextSize = 14
		lab.TextColor3 = Color3.fromRGB(230,230,255)
		lab.TextXAlignment = Enum.TextXAlignment.Left
		lab.Text = label
		lab.Parent = frame

		local function box(x)
			local b = Instance.new("TextBox")
			b.Size = UDim2.new(0, 70, 0, 22)
			b.Position = UDim2.new(0, x, 0, y)
			b.BackgroundColor3 = Color3.fromRGB(28,28,36)
			b.Font = Enum.Font.Code
			b.TextSize = 14
			b.TextColor3 = Color3.fromRGB(255,255,255)
			b.ClearTextOnFocus = false
			b.Parent = frame
			Instance.new("UICorner", b).CornerRadius=UDim.new(0,6)
			return b
		end

		local xB,yB,zB = box(110), box(185), box(260)

		local function setFromVec(v)
			xB.Text = string.format("%.1f", v.X)
			yB.Text = string.format("%.1f", v.Y)
			zB.Text = string.format("%.1f", v.Z)
		end
		setFromVec(CONFIG.coords[id])

		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(0, 70, 0, 22)
		btn.Position = UDim2.new(0, 10, 0, y+26)
		btn.BackgroundColor3 = Color3.fromRGB(40,120,40)
		btn.Font = Enum.Font.GothamBold
		btn.TextSize = 14
		btn.TextColor3 = Color3.fromRGB(255,255,255)
		btn.Text = "TP "..label
		btn.Parent = frame
		Instance.new("UICorner", btn).CornerRadius=UDim.new(0,6)

		local function parse(t) t=t:gsub(",","."); return tonumber(t) end
		local function updateCfg()
			local nx,ny,nz = parse(xB.Text), parse(yB.Text), parse(zB.Text)
			if nx and ny and nz then CONFIG.coords[id] = Vector3.new(nx,ny,nz) end
		end

		btn.MouseButton1Click:Connect(function()
			updateCfg()
			UI.tpTo(CONFIG.coords[id])
		end)
	end

	coordRow(38, "joetation", "joetation")
	coordRow(86, "coconut_bonk", "coconut_bonk")

	local auto = Instance.new("TextButton")
	auto.Size = UDim2.new(0, 90, 0, 22)
	auto.Position = UDim2.new(0, 250, 0, 8)
	auto.BackgroundColor3 = Color3.fromRGB(60,60,90)
	auto.Font = Enum.Font.GothamBold
	auto.TextSize = 14
	auto.TextColor3 = Color3.fromRGB(255,255,255)
	auto.Text = CONFIG.autoEnabled and "AUTO: ON" or "AUTO: OFF"
	auto.Parent = frame
	Instance.new("UICorner", auto).CornerRadius=UDim.new(0,6)
	auto.MouseButton1Click:Connect(function()
		CONFIG.autoEnabled = not CONFIG.autoEnabled
		auto.Text = CONFIG.autoEnabled and "AUTO: ON" or "AUTO: OFF"
		toast(CONFIG.autoEnabled and "Auto activado" or "Auto desactivado")
	end)

	UI.gui = gui
end

------------------ Teleport por coordenadas (seguro) ------------------
local function getRoot()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	return char:WaitForChild("HumanoidRootPart"), char:WaitForChild("Humanoid")
end

function UI.tpTo(vec3)
	local root, hum = getRoot()
	if not root then return end

	-- Pide streaming si está habilitado (mejora el spawn)
	if workspace.StreamingEnabled then
		pcall(function()
			LocalPlayer:RequestStreamAroundAsync(vec3, 128)
		end)
	end

	local oldState = hum:GetState()
	-- Breve modo Physics para evitar “choques”
	pcall(function() hum:ChangeState(Enum.HumanoidStateType.Physics) end)

	local look = (root.CFrame * CFrame.new(0,0,-1)).Position
	root.CFrame = CFrame.new(vec3 + Vector3.new(0,3,0), look)

	task.delay(0.12, function()
		if hum and hum.Parent then pcall(function() hum:ChangeState(oldState) end) end
	end)
end

------------------ Leer estado / ETA real ------------------
local function getClient(id)
	if not MinigameClientManager or not MinigameClientManager.get then return nil end
	local ok, cli = pcall(function() return MinigameClientManager.get(id) end)
	return ok and cli or nil
end

local function readStatus(cli)
	local st = { active=false, loading=false, inQueue=false, timeLeft=nil, raw=nil }
	local ms = cli and cli.minigame_state
	local now = srvNow()

	if ms then
		local get = (type(ms.get)=="function") and function(k) local ok,v=pcall(function() return ms:get(k) end); return ok and v or nil end or function() return nil end
		st.active  = get("is_game_active") or false
		st.loading = get("players_loading") or false

		if type(ms.get_as_table)=="function" then
			local t=nil; pcall(function() t = ms:get_as_table("queued_user_ids") end)
			if type(t)=="table" then for _,uid in ipairs(t) do if uid==LocalPlayer.UserId then st.inQueue=true break end end end
		end

		local zts = get("zone_override_timestamp")
		if typeof(zts)=="number" and zts>0 then st.timeLeft = math.max(0, math.floor(zts - now)); st.raw="zone_override_timestamp" end
	end

	if cli and cli.is_participating and cli.end_time then
		st.active = true
		st.timeLeft = math.max(0, math.floor(cli.end_time - now)); st.raw = st.raw or "client.end_time"
	end

	if (not st.timeLeft) and ClientData and cli and cli.cycle_timestamp_key then
		pcall(function()
			local rec = ClientData.get(cli.cycle_timestamp_key)
			local ts = rec and (rec.timestamp or rec.t or rec.next_timestamp)
			if ts then st.timeLeft = math.max(0, math.floor(ts - now)); st.raw="ClientData.cycle_timestamp" end
		end)
	end
	return st
end

local function etaToStart(cli, st)
	if st.active then return (st.timeLeft or CONFIG.defaultQueueCountdown) + CONFIG.inProgressGrace, false, st.raw end
	if st.loading then return 5, true, "players_loading" end
	if st.timeLeft and st.timeLeft>0 then return st.timeLeft, true, st.raw end
	return CONFIG.defaultQueueCountdown, true, "fallback"
end

local function statusAndEta(id)
	local cli = getClient(id); if not cli then return nil end
	local st = readStatus(cli)
	local eta, joinable, raw = etaToStart(cli, st)
	return { cli=cli, st=st, eta=eta, joinable=joinable, raw=raw }
end

local ORDER = { "joetation", "coconut_bonk" }
local function pickBest()
	local bestId, bestEta
	for _, id in ipairs(ORDER) do
		local r = statusAndEta(id)
		if r then
			if r.eta < (bestEta or math.huge) then bestId, bestEta = id, r.eta end
			print(string.format("[ETA] %s → %s (%s)", id, fmtTime(r.eta), r.raw or "fallback"))
		end
	end
	return bestId or "joetation"
end

------------------ Auto‑play ------------------
local dynCad, lastAct = {}, {}
for k,v in pairs(CONFIG.actionCadence) do dynCad[k]=v end
local function canAct(id)
	local cad = dynCad[id] or 1.5
	local t = LiveOpsTime.now()
	if not lastAct[id] or (t-lastAct[id])>=cad then lastAct[id]=t; return true end
	return false
end
local function tuneCad(id, ok)
	local cad = dynCad[id] or 1.5
	if ok then cad = math.max(CONFIG.minCadence, cad-CONFIG.cadenceStepDown)
	else cad = math.min(CONFIG.maxCadence, cad+CONFIG.cadenceStepUp) end
	dynCad[id]=cad
end

local function act_joetation(cli)
	if not canAct("joetation") then return end
	local root = hrp(); local pos = root and root.Position or Vector3.new()
	pcall(function() cli:message_server("pickup_holdable_from_pile", pos, LiveOpsTime.now()) end)
	-- Selecciona el cañón más cercano
	local idx = 1
	pcall(function()
		if cli.cannons_world and #cli.cannons_world>0 and pos then
			local best, bestIdx
			for i,p in ipairs(cli.cannons_world) do local d=(p-pos).Magnitude if not best or d<best then best,bestIdx=d,i end end
			idx = bestIdx or 1
		end
	end)
	local ok = pcall(function() return cli:message_server("use_cannon", idx, pos, LiveOpsTime.now()) end)
	tuneCad("joetation", ok)
end

local function act_coconut(cli)
	if not canAct("coconut_bonk") then return end
	pcall(function() cli:message_server("pickup_droppable", 1) end)
	local root = hrp(); local me = root and root.Position or Vector3.new()
	local bestUid, bestScore
	pcall(function()
		for uid, ship in pairs(cli.ships_by_uid or {}) do
			local hp = (ship.ship_data and ship.ship_data.health) or 1
			local p  = ship.base and ship.base.PrimaryPart and ship.base.PrimaryPart.Position
			local dist = p and (p-me).Magnitude or 1000
			local score = hp - dist*0.02
			if not bestScore or score>bestScore then bestScore, bestUid = score, uid end
		end
	end)
	if bestUid then
		local ok = pcall(function() return cli:message_server("used_droppable", bestUid) end)
		tuneCad("coconut_bonk", ok)
	end
end

local rewardRoutes = {"claim_rewards","collect_rewards","request_rewards","request_reward_payout","claim_payout","claim_xp"}
local function claimRewards(cli) for _, r in ipairs(rewardRoutes) do if pcall(function() return cli:message_server(r) end) then return true end end end

------------------ Anti‑AFK ------------------
if CONFIG.enableAFK then
	LocalPlayer.Idled:Connect(function()
		local vu = game:GetService("VirtualUser")
		vu:CaptureController(); vu:ClickButton2(Vector2.new())
	end)
end

------------------ Bucle AUTO ------------------
task.spawn(function()
	toast("AutoMG v4.6 listo (AUTO ON)")
	while true do
		if CONFIG.autoEnabled then
			-- Si no estamos en ningún minijuego, elegir cola más corta y TP por coordenadas
			local anyPlaying = false
			for _, id in ipairs(ORDER) do
				local r = statusAndEta(id)
				if r and r.cli and r.cli.is_participating then anyPlaying = true end
			end

			if not anyPlaying then
				local best = pickBest()
				local targetV3 = CONFIG.coords[best] or CONFIG.coords.joetation
				UI.tpTo(targetV3)
				-- (Solo si lo quieres) join explícito:
				if CONFIG.sendJoinMessageAfterTP then
					local r = statusAndEta(best)
					if r and r.cli and r.cli.message_server then pcall(function() r.cli:message_server("join_queue") end) end
				end
				-- Espera pequeña entre decisiones
				task.wait(2)
			else
				-- Estamos jugando → actuar
				for _, id in ipairs(ORDER) do
					local r = statusAndEta(id)
					if r and r.cli and r.cli.is_participating then
						if id=="joetation" then act_joetation(r.cli) else act_coconut(r.cli) end
					elseif r and r.cli and (not r.cli.is_participating) then
						-- Fin de juego → reclamar y el loop seguirá con nueva elección
						claimRewards(r.cli)
					end
				end
				task.wait(0.1)
			end
		else
			task.wait(0.25)
		end
		task.wait(CONFIG.statusRefresh)
	end
end)
