-- v9-final ‚Äî L√≠nea 1 sin llamadas
local __L1_SAFE__ = true
-- Fsys EXACTO en l√≠nea 2 (como pediste)
local Fsys = require(game.ReplicatedStorage:WaitForChild("Fsys")).load

-- Servicios / arranque
local Players = game:GetService("Players")
local RS      = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LP = Players.LocalPlayer
if not RunService:IsClient() or not LP then return end

-- Logs
local function LOG(tag, ...) print(string.format("%s %s", tag, os.date("!%H:%M:%S")), ...) end
local function logI(...) LOG("üü¢ [AutoMG]", ...) end
local function logW(...) LOG("‚ö†Ô∏è  [AutoMG]", ...) end
local function logS(...) LOG("‚úÖ [AutoMG]", ...) end
logI("AutoMinigames v9-final arrancando‚Ä¶")

-- Carga de m√≥dulos
local function loadM(name)
	local ok, mod = pcall(function() return Fsys(name) end)
	if ok and mod ~= nil then logI("M√≥dulo via Fsys:", name) return mod end
	for _,d in ipairs(RS:GetDescendants()) do
		if d:IsA("ModuleScript") and d.Name == name then
			local ok2, got = pcall(require, d)
			if ok2 and got ~= nil then logI("M√≥dulo por b√∫squeda:", name, "‚Üê", d:GetFullName()); return got end
		end
	end
	logW("No se pudo cargar m√≥dulo:", name); return nil
end

local LiveOpsTime           = loadM("LiveOpsTime") or { now=function() return os.clock() end }
local MinigameClientManager = loadM("MinigameClientManager") -- puede ser nil (se reintenta)
local ClientData            = loadM("ClientData")            -- opcional

-- Config
local CONFIG = {
	autoEnabled           = true,
	statusRefresh         = 1.0,
	defaultQueueCountdown = 12,
	inProgressGrace       = 5,

	coords = {
		joetation    = Vector3.new(-590.8, 35.8, -1667.1),
		coconut_bonk = Vector3.new(-600.3, 41.6, -1610.3),
	},

	sendJoinMessageAfterTP = false,

	actionCadence = { joetation = 0.85, coconut_bonk = 0.80 },
	minCadence = 0.45, maxCadence = 2.00, stepDown = 0.06, stepUp = 0.10,

	joetation = { triesPerAct = 5, fallbackMaxIdx = 14 },
	coconut   = { pilesToCycle = 5, usesPerAct = 5 },

	burstThreshold = 7,   -- s
	burstMultiplier = 2,

	enableAFK = true,
	verboseRPC = true,
}

-- Utils
local function nowS() return LiveOpsTime.now() end
local function srvNow() if typeof(workspace.GetServerTimeNow)=="function" then return workspace:GetServerTimeNow() end return nowS() end
local function hrp() local c=LP.Character; return c and c:FindFirstChild("HumanoidRootPart") end
local function fmtTime(s) s=math.max(0,math.floor(s)); return string.format("%02d:%02d", math.floor(s/60), s%60) end

-- TP
local function getRoot()
	local char = LP.Character or LP.CharacterAdded:Wait()
	return char:WaitForChild("HumanoidRootPart"), char:WaitForChild("Humanoid")
end
local function tpTo(v3)
	if typeof(v3)~="Vector3" then return end
	local root, hum = getRoot(); if not root or not hum then return end
	if workspace.StreamingEnabled and typeof(LP.RequestStreamAroundAsync)=="function" then
		pcall(function() LP:RequestStreamAroundAsync(v3, 128) end)
	end
	local oldState; pcall(function() oldState=hum:GetState(); hum:ChangeState(Enum.HumanoidStateType.Physics) end)
	local look=(root.CFrame*CFrame.new(0,0,-1)).Position
	root.CFrame=CFrame.new(v3+Vector3.new(0,3,0), look)
	task.delay(0.12, function() if hum and hum.Parent then pcall(function() if oldState then hum:ChangeState(oldState) end end) end)
end

-- Estado/ETA
local function refreshMgr()
	if not MinigameClientManager then MinigameClientManager = loadM("MinigameClientManager") end
	return MinigameClientManager
end
local function getClient(id)
	if not refreshMgr() or typeof(MinigameClientManager.get)~="function" then return nil end
	local ok, cli = pcall(function() return MinigameClientManager.get(id) end)
	return ok and cli or nil
end
local function readStatus(cli)
	local st={active=false,loading=false,inQueue=false,timeLeft=nil,raw=nil}
	local ms=cli and cli.minigame_state
	local now=srvNow()
	if ms then
		local get=(typeof(ms.get)=="function") and function(k) local ok,v=pcall(function() return ms:get(k) end); return ok and v or nil end or function() return nil end
		st.active  = get("is_game_active") or false
		st.loading = get("players_loading") or false
		if typeof(ms.get_as_table)=="function" then
			local t; pcall(function() t=ms:get_as_table("queued_user_ids") end)
			if type(t)=="table" then for _,uid in ipairs(t) do if uid==LP.UserId then st.inQueue=true break end end end
		end
		local zts=get("zone_override_timestamp")
		if typeof(zts)=="number" and zts>0 then st.timeLeft=math.max(0,math.floor(zts-now)); st.raw="zone_override_timestamp" end
	end
	if cli and cli.is_participating and cli.end_time then st.active=true; st.timeLeft=math.max(0,math.floor(cli.end_time-now)); st.raw=st.raw or "client.end_time" end
	if (not st.timeLeft) and ClientData and cli and cli.cycle_timestamp_key and typeof(ClientData.get)=="function" then
		pcall(function() local rec=ClientData.get(cli.cycle_timestamp_key); local ts=rec and (rec.timestamp or rec.t or rec.next_timestamp)
			if ts then st.timeLeft=math.max(0,math.floor(ts-now)); st.raw="ClientData.cycle_timestamp" end end)
	end
	return st
end
local function etaToStart(cli, st)
	if st.active then return (st.timeLeft or CONFIG.defaultQueueCountdown)+CONFIG.inProgressGrace, false, st.raw end
	if st.loading then return 5, true, "players_loading" end
	if st.timeLeft and st.timeLeft>0 then return st.timeLeft, true, st.raw end
	return CONFIG.defaultQueueCountdown, true, "fallback"
end
local function statusAndEta(id)
	local cli=getClient(id); if not cli then return nil end
	local st=readStatus(cli); local eta,joinable,raw=etaToStart(cli,st)
	return { id=id, cli=cli, st=st, eta=eta, joinable=joinable, raw=raw }
end
local ORDER={"joetation","coconut_bonk"}
local function pickBest()
	local best,bestEta
	for _,id in ipairs(ORDER) do
		local r=statusAndEta(id)
		if r then
			logI(string.format("üì° ETA %-13s ‚Üí ‚è± %s (%s) active=%s inQueue=%s",
				id, fmtTime(r.eta), r.raw or "fallback", tostring(r.st.active), tostring(r.st.inQueue)))
			if r.eta < (bestEta or math.huge) then best,bestEta=id,r.eta end
		else logW("üì° ETA "..id.." ‚Üí sin datos") end
	end
	return best or "joetation"
end

-- Autoplay
local dynCad, lastAct = {}, {}
for k,v in pairs(CONFIG.actionCadence) do dynCad[k]=v end
local function canAct(id) local cad=dynCad[id] or 1.0; local t=nowS(); if not lastAct[id] or (t-lastAct[id])>=cad then lastAct[id]=t; return true end return false end
local function tuneCad(id, ok, burst) local cad=dynCad[id] or 1.0
	if ok then cad=math.max(CONFIG.minCadence, cad-CONFIG.stepDown*(burst and 1.5 or 1)) else cad=math.min(CONFIG.maxCadence, cad+CONFIG.stepUp) end
	dynCad[id]=cad; logI(string.format("‚è≤Ô∏è Cadencia %-13s ‚Üí %.2fs (ok=%s, burst=%s)", id, cad, tostring(ok), tostring(burst)))
end
local function rpc(cli, route, ...) if not cli or typeof(cli.message_server)~="function" then return false end
	local ok,err=pcall(function() return cli:message_server(route, ...) end); if not ok and CONFIG.verboseRPC then logW("üì® RPC FAIL:", route, err) end; return ok end

local cannonCursor, shipCursor, pileIdx = 1,1,1
local function cannonList(cli) local arr={}; local ok,list=pcall(function() return cli.cannons_world end); list=ok and list or nil
	if type(list)=="table" and #list>0 then for i=1,#list do arr[#arr+1]=i end else for i=1,CONFIG.joetation.fallbackMaxIdx do arr[#arr+1]=i end end return arr end
local function shipUidList(cli) local arr={}; local ok,map=pcall(function() return cli.ships_by_uid end); map=ok and map or nil
	if type(map)=="table" then for uid,_ in pairs(map) do arr[#arr+1]=uid end end return arr end

local function act_joetation(cli, r)
	if not canAct("joetation") then return end
	local tleft = r and r.st and r.st.timeLeft or nil
	local burst = (tleft and tleft <= CONFIG.burstThreshold)
	local root=hrp(); local pos=root and root.Position or Vector3.new()
	rpc(cli, "pickup_holdable_from_pile", pos, nowS()); logI("üéí [joetation] pickup_holdable_from_pile")
	local list=cannonList(cli); local tries=CONFIG.joetation.triesPerAct*(burst and CONFIG.burstMultiplier or 1); local okAny=false
	for n=1, math.max(1, tries) do if #list==0 then break end
		local idx=list[cannonCursor]; cannonCursor=(cannonCursor % #list)+1
		local ok=rpc(cli,"use_cannon", idx, pos, nowS())
		logI(string.format("üí• [joetation] %s %d/%d ‚Üí cannon=%d ‚Üí ok=%s", burst and "[BURST]" or "intento", n, tries, idx, tostring(ok)))
		okAny = okAny or ok
	end
	if not okAny then logW("üí§ [joetation] sin disparo exitoso este tick") end
	tuneCad("joetation", okAny, burst)
end

local function act_coconut(cli, r)
	if not canAct("coconut_bonk") then return end
	local tleft = r and r.st and r.st.timeLeft or nil
	local burst = (tleft and tleft <= CONFIG.burstThreshold)
	rpc(cli, "pickup_droppable", pileIdx)
	logI(string.format("üéí [coconut] pickup_droppable ‚Üí pile=%d%s", pileIdx, burst and " [BURST]" or ""))
	pileIdx = (pileIdx % CONFIG.coconut.pilesToCycle) + 1
	local uids=shipUidList(cli); if #uids==0 then logW("üõ∂ [coconut] ships_by_uid vac√≠o"); tuneCad("coconut_bonk", false, burst); return end
	local uses=CONFIG.coconut.usesPerAct*(burst and CONFIG.burstMultiplier or 1); local okAny=false
	for n=1, math.max(1, uses) do if shipCursor>#uids then shipCursor=1 end
		local uid=uids[shipCursor]; shipCursor = shipCursor + 1
		local ok=rpc(cli,"used_droppable", uid)
		logI(string.format("üîß [coconut] %s %d/%d ‚Üí uid=%s ‚Üí ok=%s", burst and "[BURST]" or "intento", n, uses, tostring(uid), tostring(ok)))
		okAny = okAny or ok
	end
	if not okAny then logW("üí§ [coconut] sin uso exitoso este tick") end
	tuneCad("coconut_bonk", okAny, burst)
end

-- Anti-AFK
if CONFIG.enableAFK then
	LP.Idled:Connect(function()
		local vu = game:GetService("VirtualUser")
		vu:CaptureController(); vu:ClickButton2(Vector2.new())
		logI("üñ±Ô∏è Anti‚ÄëAFK: click simulado.")
	end)
end

-- Bucle principal
task.spawn(function()
	logI("‚ú® Listo. AUTO =", CONFIG.autoEnabled and "ON" or "OFF")
	local currentPlaying
	while true do
		if CONFIG.autoEnabled then
			local anyPlaying, playingId = false, nil
			for _, id in ipairs(ORDER) do local r=statusAndEta(id); if r and r.cli and r.cli.is_participating then anyPlaying=true; playingId=id end end
			if not anyPlaying then
				local best=pickBest(); if currentPlaying ~= nil then logS("üèÅ Partida anterior finalizada.") end; currentPlaying=nil
				local target=CONFIG.coords[best] or CONFIG.coords.joetation
				logI(string.format("üß≠ TP ‚Üí %-13s @ (%.1f, %.1f, %.1f)", best, target.X, target.Y, target.Z)); tpTo(target)
				if CONFIG.sendJoinMessageAfterTP then local r=statusAndEta(best); if r and r.cli then pcall(function() r.cli:message_server("join_queue") end) end; logI("üì® join_queue (opcional) enviado.") end
				task.wait(2)
			else
				if currentPlaying ~= playingId then currentPlaying=playingId; cannonCursor,shipCursor,pileIdx=1,1,1; logS("üéÆ Entraste a "..currentPlaying.." (FULL)") end
				local r=statusAndEta(currentPlaying); if r and r.cli and r.cli.is_participating then
					if currentPlaying=="joetation" then act_joetation(r.cli, r) else act_coconut(r.cli, r) end
				end
				task.wait(0.1)
			end
		else task.wait(0.25) end
		task.wait(CONFIG.statusRefresh)
	end
end)
