--!nonstrict
-- AutoMinigames – TP por coordenadas + Smart ETA + AutoPlay (v4.8)
-- Requisitos: LocalScript en StarterPlayerScripts

--[[ Resumen
✅ UI simple: editar coords + TP manual + switch AUTO
✅ TP por coordenadas con streaming y estado seguro del Humanoid
✅ Lee ETA/estado y auto‑play SOLO si existen los módulos del juego
✅ Todo envuelto en pcall + guards (no se llama nada si es nil)
✅ Anti‑AFK opcional
TIP: Ocultar/mostrar UI con RightShift
]]

local ok_boot, boot_err = pcall(function()

	------------------ Servicios ------------------
	local Players     = game:GetService("Players")
	local RS          = game:GetService("ReplicatedStorage")
	local RunService  = game:GetService("RunService")
	local StarterGui  = game:GetService("StarterGui")
	local UIS         = game:GetService("UserInputService")

	-- Debe ser LocalScript (cliente)
	if not RunService:IsClient() then warn("[AutoMG] Este script es SOLO para cliente (LocalScript)."); return end
	local LocalPlayer = Players.LocalPlayer
	if not LocalPlayer then
		-- En servidor LocalPlayer es nil; abortamos limpio.
		return
	end

	------------------ Helpers ------------------
	local function isFn(x) return type(x) == "function" end
	local function isMS(x) return typeof(x) == "Instance" and x:IsA("ModuleScript") end
	local function srequire(ms)
		if not isMS(ms) then return nil end
		local ok, mod = pcall(function() return require(ms) end)
		return ok and mod or nil
	end

	-- Carga opcional por nombre (Fsys o búsqueda en RS)
	local function loadM(name)
		local Fsys = srequire(RS:FindFirstChild("Fsys"))
		local FSYS_LOAD = Fsys and isFn(Fsys.load) and Fsys.load or nil
		if FSYS_LOAD then
			local ok, m = pcall(function() return FSYS_LOAD(name) end)
			if ok and m then return m end
		end
		for _, rootName in ipairs({ "ClientModules", "SharedModules" }) do
			local root = RS:FindFirstChild(rootName, true)
			if root then
				local m = root:FindFirstChild(name, true)
				local got = srequire(m)
				if got then return got end
			end
		end
		return nil
	end

	------------------ Módulos opcionales ------------------
	local LiveOpsTime           = loadM("LiveOpsTime") or { now = function() return os.clock() end }
	local MinigameClientManager = loadM("MinigameClientManager") -- puede ser nil
	local ClientData            = loadM("ClientData")            -- puede ser nil

	------------------ Config ------------------
	local CONFIG = {
		autoEnabled = true,
		statusRefresh = 1.0,        -- s
		defaultQueueCountdown = 12, -- fallback ETA
		inProgressGrace = 5,        -- s

		coords = {
			coconut_bonk = Vector3.new(-600.3, 41.6, -1610.3),
			joetation    = Vector3.new(-590.8, 35.8, -1667.1),
		},

		sendJoinMessageAfterTP = false,

		actionCadence = { joetation = 1.25, coconut_bonk = 1.50 },
		minCadence = 0.6, maxCadence = 2.5, cadenceStepDown = 0.10, cadenceStepUp = 0.15,

		enableAFK = true,
	}

	------------------ Utils ------------------
	local function toast(t)
		pcall(function()
			StarterGui:SetCore("SendNotification", { Title = "AutoMG", Text = t, Duration = 2 })
		end)
	end

	local function fmtTime(s)
		s = math.max(0, math.floor(s))
		return string.format("%02d:%02d", math.floor(s/60), s%60)
	end

	local function hrp()
		local c = LocalPlayer.Character
		return c and c:FindFirstChild("HumanoidRootPart")
	end

	local function humanoid()
		local c = LocalPlayer.Character
		return c and c:FindFirstChildWhichIsA("Humanoid")
	end

	local function srvNow()
		if isFn(workspace.GetServerTimeNow) then
			return workspace:GetServerTimeNow()
		end
		return LiveOpsTime.now()
	end

	------------------ UI (coords + TP + AUTO + toggle visible) ------------------
	local UI = {}
	do
		local gui = Instance.new("ScreenGui")
		gui.Name = "AutoMG_UI"
		gui.ResetOnSpawn = false
		gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

		local frame = Instance.new("Frame")
		frame.Size = UDim2.new(0, 350, 0, 160)
		frame.Position = UDim2.new(0, 10, 0, 10)
		frame.BackgroundTransparency = 0.2
		frame.BackgroundColor3 = Color3.fromRGB(18, 18, 24)
		frame.Parent = gui
		Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)

		local title = Instance.new("TextLabel")
		title.Size = UDim2.new(1, -10, 0, 22)
		title.Position = UDim2.new(0, 10, 0, 8)
		title.BackgroundTransparency = 1
		title.Font = Enum.Font.GothamBold
		title.TextSize = 18
		title.TextColor3 = Color3.fromRGB(255,255,255)
		title.Text = "AutoMG v4.8 – TP coords + Auto"
		title.TextXAlignment = Enum.TextXAlignment.Left
		title.Parent = frame

		local function coordRow(y, label, id)
			local lab = Instance.new("TextLabel")
			lab.Size = UDim2.new(0, 95, 0, 22)
			lab.Position = UDim2.new(0, 10, 0, y)
			lab.BackgroundTransparency = 1
			lab.Font = Enum.Font.Gotham
			lab.TextSize = 14
			lab.TextColor3 = Color3.fromRGB(230,230,255)
			lab.TextXAlignment = Enum.TextXAlignment.Left
			lab.Text = label
			lab.Parent = frame

			local function box(x)
				local b = Instance.new("TextBox")
				b.Size = UDim2.new(0, 70, 0, 22)
				b.Position = UDim2.new(0, x, 0, y)
				b.BackgroundColor3 = Color3.fromRGB(28,28,36)
				b.Font = Enum.Font.Code
				b.TextSize = 14
				b.TextColor3 = Color3.fromRGB(255,255,255)
				b.ClearTextOnFocus = false
				b.Parent = frame
				Instance.new("UICorner", b).CornerRadius = UDim.new(0, 6)
				return b
			end

			local xB, yB, zB = box(110), box(185), box(260)

			local function setFromVec(v)
				if typeof(v) == "Vector3" then
					xB.Text = string.format("%.1f", v.X)
					yB.Text = string.format("%.1f", v.Y)
					zB.Text = string.format("%.1f", v.Z)
				end
			end
			setFromVec(CONFIG.coords[id])

			local btn = Instance.new("TextButton")
			btn.Size = UDim2.new(0, 70, 0, 22)
			btn.Position = UDim2.new(0, 10, 0, y + 26)
			btn.BackgroundColor3 = Color3.fromRGB(40,120,40)
			btn.Font = Enum.Font.GothamBold
			btn.TextSize = 14
			btn.TextColor3 = Color3.fromRGB(255,255,255)
			btn.Text = "TP " .. label
			btn.Parent = frame
			Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)

			local function parse(t)
				if not t then return nil end
				t = tostring(t):gsub(",", ".")
				return tonumber(t)
			end

			local function updateCfg()
				local nx, ny, nz = parse(xB.Text), parse(yB.Text), parse(zB.Text)
				if nx and ny and nz then
					CONFIG.coords[id] = Vector3.new(nx, ny, nz)
				end
			end

			btn.MouseButton1Click:Connect(function()
				updateCfg()
				UI.tpTo(CONFIG.coords[id])
			end)
		end

		coordRow(38, "joetation", "joetation")
		coordRow(86, "coconut_bonk", "coconut_bonk")

		local auto = Instance.new("TextButton")
		auto.Size = UDim2.new(0, 90, 0, 22)
		auto.Position = UDim2.new(0, 250, 0, 8)
		auto.BackgroundColor3 = Color3.fromRGB(60,60,90)
		auto.Font = Enum.Font.GothamBold
		auto.TextSize = 14
		auto.TextColor3 = Color3.fromRGB(255,255,255)
		auto.Text = CONFIG.autoEnabled and "AUTO: ON" or "AUTO: OFF"
		auto.Parent = frame
		Instance.new("UICorner", auto).CornerRadius = UDim.new(0, 6)
		auto.MouseButton1Click:Connect(function()
			CONFIG.autoEnabled = not CONFIG.autoEnabled
			auto.Text = CONFIG.autoEnabled and "AUTO: ON" or "AUTO: OFF"
			toast(CONFIG.autoEnabled and "Auto activado" or "Auto desactivado")
		end)

		-- Toggle visibilidad con RightShift
		UIS.InputBegan:Connect(function(input, gp)
			if gp then return end
			if input.KeyCode == Enum.KeyCode.RightShift then
				gui.Enabled = not gui.Enabled
			end
		end)

		UI.gui = gui
	end

	------------------ TP seguro ------------------
	local function getRoot()
		local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
		return char:WaitForChild("HumanoidRootPart"), char:WaitForChild("Humanoid")
	end

	function UI.tpTo(vec3)
		if typeof(vec3) ~= "Vector3" then return end
		local root, hum = getRoot()
		if not root or not hum then return end

		-- Streaming
		if workspace.StreamingEnabled and isFn(LocalPlayer.RequestStreamAroundAsync) then
			pcall(function() LocalPlayer:RequestStreamAroundAsync(vec3, 128) end)
		end

		local oldState
		pcall(function()
			oldState = hum:GetState()
			hum:ChangeState(Enum.HumanoidStateType.Physics)
		end)

		local look = (root.CFrame * CFrame.new(0,0,-1)).Position
		root.CFrame = CFrame.new(vec3 + Vector3.new(0, 3, 0), look)

		task.delay(0.12, function()
			if hum and hum.Parent then
				pcall(function()
					if oldState then hum:ChangeState(oldState) end
				end)
			end
		end)
	end

	------------------ Estado / ETA (si hay módulos) ------------------
	local function getClient(id)
		if not MinigameClientManager or not isFn(MinigameClientManager.get) then
			return nil
		end
		local ok, cli = pcall(function() return MinigameClientManager.get(id) end)
		return ok and cli or nil
	end

	local function readStatus(cli)
		local st = { active=false, loading=false, inQueue=false, timeLeft=nil, raw=nil }
		local ms = cli and cli.minigame_state
		local now = srvNow()

		if ms then
			local get = isFn(ms.get) and function(k)
				local ok, v = pcall(function() return ms:get(k) end)
				return ok and v or nil
			end or function() return nil end

			st.active  = get("is_game_active") or false
			st.loading = get("players_loading") or false

			if isFn(ms.get_as_table) then
				local t; pcall(function() t = ms:get_as_table("queued_user_ids") end)
				if type(t) == "table" then
					for _, uid in ipairs(t) do
						if uid == LocalPlayer.UserId then st.inQueue = true break end
					end
				end
			end

			local zts = get("zone_override_timestamp")
			if typeof(zts) == "number" and zts > 0 then
				st.timeLeft = math.max(0, math.floor(zts - now)); st.raw = "zone_override_timestamp"
			end
		end

		if cli and cli.is_participating and cli.end_time then
			st.active = true
			st.timeLeft = math.max(0, math.floor(cli.end_time - now)); st.raw = st.raw or "client.end_time"
		end

		if (not st.timeLeft) and ClientData and cli and cli.cycle_timestamp_key and isFn(ClientData.get) then
			pcall(function()
				local rec = ClientData.get(cli.cycle_timestamp_key)
				local ts = rec and (rec.timestamp or rec.t or rec.next_timestamp)
				if ts then st.timeLeft = math.max(0, math.floor(ts - now)); st.raw = "ClientData.cycle_timestamp" end
			end)
		end

		return st
	end

	local function etaToStart(cli, st)
		if st.active then return (st.timeLeft or CONFIG.defaultQueueCountdown) + CONFIG.inProgressGrace, false, st.raw end
		if st.loading then return 5, true, "players_loading" end
		if st.timeLeft and st.timeLeft > 0 then return st.timeLeft, true, st.raw end
		return CONFIG.defaultQueueCountdown, true, "fallback"
	end

	local function statusAndEta(id)
		local cli = getClient(id); if not cli then return nil end
		local st = readStatus(cli)
		local eta, joinable, raw = etaToStart(cli, st)
		return { cli=cli, st=st, eta=eta, joinable=joinable, raw=raw }
	end

	local ORDER = { "joetation", "coconut_bonk" }
	local function pickBest()
		local bestId, bestEta
		for _, id in ipairs(ORDER) do
			local r = statusAndEta(id)
			if r then
				if r.eta < (bestEta or math.huge) then bestId, bestEta = id, r.eta end
				print(string.format("[ETA] %s → %s (%s)", id, fmtTime(r.eta), r.raw or "fallback"))
			end
		end
		return bestId or "joetation"
	end

	------------------ Auto‑play (solo si hay cliente y rutas) ------------------
	local dynCad, lastAct = {}, {}
	for k, v in pairs(CONFIG.actionCadence) do dynCad[k] = v end

	local function canAct(id)
		local cad = dynCad[id] or 1.5
		local t = LiveOpsTime.now()
		if not lastAct[id] or (t - lastAct[id]) >= cad then lastAct[id] = t; return true end
		return false
	end

	local function tuneCad(id, ok)
		local cad = dynCad[id] or 1.5
		if ok then cad = math.max(CONFIG.minCadence, cad - CONFIG.cadenceStepDown)
		else cad = math.min(CONFIG.maxCadence, cad + CONFIG.cadenceStepUp) end
		dynCad[id] = cad
	end

	local function cliCall(cli, route, ...)
		if not cli or not isFn(cli.message_server) then return false end
		local ok = pcall(function() return cli:message_server(route, ...) end)
		return ok
	end

	local function act_joetation(cli)
		if not canAct("joetation") then return end
		local root = hrp(); local pos = root and root.Position or Vector3.new()
		cliCall(cli, "pickup_holdable_from_pile", pos, LiveOpsTime.now())

		-- Cañón más cercano
		local idx = 1
		pcall(function()
			if cli.cannons_world and #cli.cannons_world > 0 and pos then
				local best, bestIdx
				for i, p in ipairs(cli.cannons_world) do
					local d = (p - pos).Magnitude
					if not best or d < best then best, bestIdx = d, i end
				end
				idx = bestIdx or 1
			end
		end)

		local ok = cliCall(cli, "use_cannon", idx, pos, LiveOpsTime.now())
		tuneCad("joetation", ok)
	end

	local function act_coconut(cli)
		if not canAct("coconut_bonk") then return end
		cliCall(cli, "pickup_droppable", 1)

		local root = hrp(); local me = root and root.Position or Vector3.new()
		local bestUid, bestScore
		pcall(function()
			for uid, ship in pairs(cli.ships_by_uid or {}) do
				local hp = (ship.ship_data and ship.ship_data.health) or 1
				local p  = ship.base and ship.base.PrimaryPart and ship.base.PrimaryPart.Position
				local dist = p and (p - me).Magnitude or 1000
				local score = hp - dist * 0.02
				if not bestScore or score > bestScore then bestScore, bestUid = score, uid end
			end
		end)
		if bestUid then
			local ok = cliCall(cli, "used_droppable", bestUid)
			tuneCad("coconut_bonk", ok)
		end
	end

	local rewardRoutes = { "claim_rewards","collect_rewards","request_rewards","request_reward_payout","claim_payout","claim_xp" }
	local function claimRewards(cli)
		for _, r in ipairs(rewardRoutes) do
			if cliCall(cli, r) then return true end
		end
		return false
	end

	------------------ Anti‑AFK ------------------
	if CONFIG.enableAFK then
		LocalPlayer.Idled:Connect(function()
			local vu = game:GetService("VirtualUser")
			vu:CaptureController(); vu:ClickButton2(Vector2.new())
		end)
	end

	------------------ Bucle AUTO ------------------
	task.spawn(function()
		toast("AutoMG v4.8 listo (AUTO ON)")
		while true do
			if CONFIG.autoEnabled then
				-- ¿Jugando alguno?
				local anyPlaying = false
				for _, id in ipairs(ORDER) do
					local r = statusAndEta(id)
					if r and r.cli and r.cli.is_participating then anyPlaying = true end
				end

				if not anyPlaying then
					local best = pickBest()
					local targetV3 = CONFIG.coords[best] or CONFIG.coords.joetation
					UI.tpTo(targetV3)

					if CONFIG.sendJoinMessageAfterTP then
						local r = statusAndEta(best)
						if r and r.cli then cliCall(r.cli, "join_queue") end
					end
					task.wait(2)
				else
					for _, id in ipairs(ORDER) do
						local r = statusAndEta(id)
						if r and r.cli and r.cli.is_participating then
							if id == "joetation" then act_joetation(r.cli) else act_coconut(r.cli) end
						elseif r and r.cli and (not r.cli.is_participating) then
							claimRewards(r.cli)
						end
					end
					task.wait(0.1)
				end
			else
				task.wait(0.25)
			end
			task.wait(CONFIG.statusRefresh)
		end
	end)

end) -- pcall boot

if not ok_boot then
	warn("[AutoMG] Error al iniciar: ", boot_err)
end
