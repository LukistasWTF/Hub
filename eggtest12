-- Minigames Hub (RuinRush 1.0 + Teleports con retorno por MainDoor) Â· LocalScript

--== Config
local AZTEC_ROOT_NAME = "MainMap!Aztec" -- workspace/Interiors/<esto>/Doors/*

--== Guardas y Servicios
local Players = game:GetService("Players")
if not Players.LocalPlayer then warn("[Hub] Debe ir como LocalScript en StarterPlayerScripts."); return end

local RS          = game:GetService("ReplicatedStorage")
local RunService  = game:GetService("RunService")
local StarterGui  = game:GetService("StarterGui")
local UIS         = game:GetService("UserInputService")
local VU          = game:GetService("VirtualUser")
local TweenService= game:GetService("TweenService")
local LP          = Players.LocalPlayer

--== Mensajes
local function say(msg)
	print("[Hub] "..msg)
	pcall(function() StarterGui:SetCore("ChatMakeSystemMessage",{Text="[Hub] "..msg}) end)
end

--== Fsys / Roact / DoorsM (opcionales)
local Fsys do
	local ok,res = pcall(function() return require(RS:WaitForChild("Fsys")) end)
	if ok then Fsys = res end
end

local function tryLoad(name)
	if not Fsys then return nil end
	local ok = pcall(function() return Fsys.load(name) end)
	return ok and Fsys.load(name) or nil
end

local Roact  = tryLoad("Roact")
local DoorsM = tryLoad("DoorsM")

--== Helpers
local function getHRP()
	local ch = LP.Character or LP.CharacterAdded:Wait()
	return ch:WaitForChild("HumanoidRootPart"), ch:WaitForChild("Humanoid")
end

local function formatClock(sec)
	sec = math.max(0,math.floor(sec))
	return ("%02d:%02d"):format(math.floor(sec/60), sec%60)
end

local function fadeWhite(duration, from, to, yields)
	local pg = LP:WaitForChild("PlayerGui")
	local sg = Instance.new("ScreenGui")
	sg.ResetOnSpawn=false; sg.IgnoreGuiInset=true; sg.DisplayOrder=1e6; sg.Name="RR_Fade"; sg.Parent=pg
	local f = Instance.new("Frame")
	f.BackgroundColor3=Color3.new(1,1,1); f.BorderSizePixel=0; f.Size=UDim2.fromScale(1,1); f.BackgroundTransparency=from or 1; f.Parent=sg
	local tw = TweenService:Create(f, TweenInfo.new(duration or 0.45), {BackgroundTransparency=to or 0})
	tw:Play(); if yields then tw.Completed:Wait() end
	task.delay(0.5, function() if sg.Parent then sg:Destroy() end end)
end

-- =============================================================================
--                             Puertas / navegaciÃ³n
-- =============================================================================
local function getAztecRoot()
	local interiors = workspace:FindFirstChild("Interiors")
	return interiors and interiors:FindFirstChild(AZTEC_ROOT_NAME) or nil
end

local function getAztecDoorsFolder()
	local root = getAztecRoot()
	return root and root:FindFirstChild("Doors") or nil
end

-- EstimaciÃ³n: Â¿estamos dentro del volumen de MainMap!Aztec?
local function isInAztec()
	local root = getAztecRoot(); if not root then return false end
	local cf, size = root:GetBoundingBox()
	local ch = LP.Character or LP.CharacterAdded:Wait()
	local hrp = ch:FindFirstChild("HumanoidRootPart"); if not hrp then return false end
	local p = cf:PointToObjectSpace(hrp.Position)
	return math.abs(p.X)<=size.X/2 and math.abs(p.Y)<=size.Y/2 and math.abs(p.Z)<=size.Z/2
end

-- Buscar por ruta "A/B/C"
local function findByPath(root, path)
	if not (root and path) then return end
	local node = root
	for seg in string.gmatch(path, "[^/]+") do
		node = node and node:FindFirstChild(seg)
	end
	return node
end

-- HeurÃ­stica: MainDoor mÃ¡s cercana (si estÃ¡s dentro de un interior)
local function guessCurrentMainDoor()
	local interiors = workspace:FindFirstChild("Interiors"); if not interiors then return end
	local ch = LP.Character or LP.CharacterAdded:Wait()
	local hrp = ch:FindFirstChild("HumanoidRootPart"); if not hrp then return end
	local best, bestDist
	for _,container in ipairs(interiors:GetChildren()) do
		local doors = container:FindFirstChild("Doors")
		local main = doors and doors:FindFirstChild("MainDoor")
		local touch = main and main:FindFirstChild("WorkingParts") and main.WorkingParts:FindFirstChild("TouchToEnter")
		if touch and touch:IsA("BasePart") then
			local d = (touch.Position - hrp.Position).Magnitude
			if not best or d < bestDist then best, bestDist = main, d end
		end
	end
	return best
end

local function ensureDoorWired(doorModel)
	if DoorsM and doorModel then pcall(function() DoorsM.get_door(doorModel) end) end
end

-- 3 pasos HACIA ATRÃS: te alejas del Touch mirando a la puerta
local function stepBackFromDoor(touch, steps, studs, waitS)
	steps = steps or 3; studs = studs or 1.25; waitS = waitS or 0.08
	local hrp,hum = getHRP()
	local lookDirIn = -touch.CFrame.LookVector  -- hacia dentro (mirando a la puerta)
	local outDir    =  touch.CFrame.LookVector  -- hacia fuera (alejarse)
	hrp.Anchored=false
	hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + lookDirIn)
	for _=1,steps do
		hrp.CFrame = CFrame.new(hrp.Position + outDir*studs, hrp.Position + lookDirIn)
		RunService.Heartbeat:Wait()
		task.wait(waitS)
	end
end

-- Cruce de Touch con empuje del Humanoid para disparar el enter
-- faceInside=true entra; false sale
local function walkThroughTouch(touch, faceInside)
	local hrp,hum = getHRP()
	if hum.Sit then
		hum.Sit=false; hum.Jump=true
		local weld = hum.SeatPart and hum.SeatPart:FindFirstChild("SeatWeld")
		if weld then weld:Destroy() end
		task.wait(0.2)
	end

	pcall(function() LP:RequestStreamAroundAsync(touch.Position, 2) end)

	local base = touch.CFrame
	local up   = Vector3.new(0, 1.6, 0)
	local outside = base.Position + base.LookVector * (touch.Size.Z/2 + 6) + up
	local inside  = base.Position - base.LookVector * (touch.Size.Z/2 + 2) + up

	local startPos = faceInside and outside or inside
	local endPos   = faceInside and inside  or outside
	local lookDir  = faceInside and (-base.LookVector) or (base.LookVector)

	hrp.Anchored=false
	hrp.CFrame = CFrame.new(startPos, startPos + lookDir)

	local pushing = true
	local hbConn = RunService.Heartbeat:Connect(function()
		if pushing and hum and hum.Parent then hum:Move(lookDir) end
	end)

	for i=0,18 do
		local pos = startPos:Lerp(endPos, i/18)
		hrp.CFrame = CFrame.new(pos, pos + lookDir)
		RunService.Heartbeat:Wait()
	end
	task.wait(0.15)
	pushing = false
	if hbConn then hbConn:Disconnect() end
end

-- =============================================================================
--                     Teleports con retorno por la misma MainDoor
-- =============================================================================
local Tele = {
	lastEnteredDoor = nil,
	busy = false,
	delayAfterExit = 5, -- seg entre salir y nuevo salto
}

local function prettyLabel(s) local i=string.find(s,"/"); return i and string.sub(s,1,i-1) or s end

function Tele.gotoDoorWithReturn(doorKey)
	if Tele.busy then say("[TP] Ocupado, esperaâ€¦"); return end
	Tele.busy = true

	task.spawn(function()
		-- A) si YA estÃ¡s en Aztec, no hay salida por puerta
		local inAztecNow = isInAztec()
		if inAztecNow then Tele.lastEnteredDoor = nil end

		-- B) si NO estÃ¡s en Aztec, sal por la misma puerta usada para entrar
		if not inAztecNow then
			if not Tele.lastEnteredDoor or not Tele.lastEnteredDoor.Parent then
				Tele.lastEnteredDoor = guessCurrentMainDoor()
			end
			local outDoor = Tele.lastEnteredDoor
			local touchOut = outDoor
				and outDoor:FindFirstChild("WorkingParts")
				and outDoor.WorkingParts:FindFirstChild("TouchToEnter")

			if touchOut and touchOut:IsA("BasePart") then
				ensureDoorWired(outDoor)
				say("[TP] Saliendo por MainDoor â†’ "..(outDoor.Name or "?"))
				fadeWhite(0.18,1,0,true)
				walkThroughTouch(touchOut, false) -- salir
				task.wait(0.05)
				fadeWhite(0.26,0,1,false)
			else
				say("[TP] No pude usar la puerta de salida (Touch faltante).")
			end

			Tele.lastEnteredDoor = nil
			task.wait(Tele.delayAfterExit)
		end

		-- C) entrar al destino
		local doors = getAztecDoorsFolder()
		if not doors then say("[TP] No encuentro Interiors/"..AZTEC_ROOT_NAME.."/Doors"); Tele.busy=false; return end

		local target = findByPath(doors, doorKey) or doors:FindFirstChild(doorKey)
		if not (target and target:IsA("Model")) then say("[TP] Door '"..doorKey.."' no existe."); Tele.busy=false; return end

		local touchIn = target:FindFirstChild("WorkingParts")
		touchIn = touchIn and touchIn:FindFirstChild("TouchToEnter")
		if not (touchIn and touchIn:IsA("BasePart")) then say("[TP] '"..doorKey.."' sin TouchToEnter."); Tele.busy=false; return end

		ensureDoorWired(target)

		-- 3 pasos hacia atrÃ¡s antes de entrar
		stepBackFromDoor(touchIn, 3, 1.25, 0.08)

		fadeWhite(0.18,1,0,true)
		walkThroughTouch(touchIn, true) -- entrar
		task.wait(0.05)
		fadeWhite(0.26,0,1,false)

		Tele.lastEnteredDoor = target
		say("[TP] Dentro â†’ "..prettyLabel(doorKey))

		Tele.busy = false
	end)
end

-- Lista de destinos
local TELEPORT_OPTIONS = {
	"AFKZone/MainDoor","AutoShop/MainDoor","AztecLobbyEntrance","AztecPortalExit",
	"BabyShop/MainDoor","BeachShop/MainDoor","CampingShop/MainDoor","Cave/MainDoor",
	"CoffeeShop/MainDoor","DebugInterior/MainDoor","HatShop/MainDoor","Hospital/MainDoor",
	"IceCream/MainDoor","Neighborhood/MainDoor","Nursery/MainDoor","Obbies/MainDoor",
	"PetShop/MainDoor","PizzaShop/MainDoor","SafetyHub/MainDoor","Salon/MainDoor",
	"School/MainDoor","SkyCastle/MainDoor","SkyCastle/MainDoor2","Supermarket/MainDoor",
	"ToyShop/MainDoor","WarpDoor",
}

-- =============================================================================
--                            RUINRUSH 1.0 (intacto)
-- =============================================================================
local ForcedState = tryLoad("MinigameForcedState")
local KillInterior = tryLoad("KillBlockInteriorManager")

local RR = {}

function RR.findExitDoor()
	local best,scoreBest
	for _,inst in ipairs(workspace:GetDescendants()) do
		if inst:IsA("BasePart") and inst.Name=="ExitDoor" then
			local s, p = 0, inst.Parent
			while p do
				local n = string.lower(p.Name)
				if n:find("ruinrush") or n:find("temple") or n:find("interior") then s+=3 end
				if p:FindFirstChild("AttachmentPoints") then s+=2 end
				if p:FindFirstChild("SpawnPoints") then s+=1 end
				p = p.Parent
			end
			if not best or s>scoreBest then best,scoreBest = inst,s end
		end
	end
	return best
end

function RR.findSafeSpawn()
	for _,f in ipairs(workspace:GetDescendants()) do
		if f:IsA("Folder") and f.Name=="SpawnPoints" and #f:GetChildren()>0 then
			local sp = f:FindFirstChild("1") or f:GetChildren()[1]
			if sp and sp:IsA("BasePart") then return sp end
		end
	end
end

function RR.sweepThrough(part)
	if not part or not part.Parent then return end
	local hrp,hum = getHRP(); hum:ChangeState(Enum.HumanoidStateType.Running); hrp.Anchored=false
	local base,size,up = part.CFrame, part.Size, Vector3.new(0,1,0)
	local a = base.Position + up*(size.Y*0.5) - base.LookVector*(size.Z+4)
	local b = base.Position + up*(size.Y*0.5) + base.LookVector*(size.Z+4)
	for i=0,12 do
		local pos = a:Lerp(b, i/12)
		hrp.CFrame = CFrame.new(pos, pos + base.LookVector)
		RunService.Heartbeat:Wait()
	end
end

function RR.touchModel(model)
	if not model or not model.Parent then return end
	local primary = model.PrimaryPart
	if not primary then
		for _,d in ipairs(model:GetDescendants()) do if d:IsA("BasePart") then primary=d; break end end
	end
	if primary then RR.sweepThrough(primary) end
end

function RR.findPedestalSkull()
	local best,bscore
	for _,m in ipairs(workspace:GetDescendants()) do
		if m:IsA("Model") and m.Name=="GoldenSkull" then
			local s,p = 0,m.Parent
			while p do
				local n=string.lower(p.Name)
				if n:find("pedastal") or n:find("uplift") then s+=4 end
				if n:find("ruinrush") or n:find("temple") then s+=2 end
				p=p.Parent
			end
			if not best or s>bscore then best,bscore=m,s end
		end
	end
	return best
end

function RR.findRealSkulls()
	local list={}
	for _,m in ipairs(workspace:GetDescendants()) do
		if m:IsA("Model") and m.Name=="GoldenSkull" then
			local p=m.Parent; local ok=false
			while p do
				if p:IsA("Folder") and p.Name=="PickupEntities" then ok=true; break end
				p=p.Parent
			end
			if ok then table.insert(list,m) end
		end
	end
	return list
end

function RR.safeOn()
	if ForcedState and type(ForcedState.set_buff)=="function" then pcall(function() ForcedState.set_buff("rr_safe",{walk_speed=22,jump_power=0}) end) end
	local sp = RR.findSafeSpawn()
	if sp and KillInterior and type(KillInterior.set_spawn_point)=="function" then pcall(function() KillInterior.set_spawn_point(sp) end) end
end
function RR.safeOff()
	if ForcedState and type(ForcedState.remove_buff)=="function" then pcall(function() ForcedState.remove_buff("rr_safe") end) end
end

function RR.ensureChaseStarted(timeout)
	timeout = timeout or 15
	local t0 = os.clock()
	local ped = RR.findPedestalSkull()
	if ped then
		say("RuinRush: activando pedestalâ€¦")
		RR.touchModel(ped)
		while os.clock()-t0 < timeout do RunService.Heartbeat:Wait() end
	end
end

function RR.collectAll(maxPasses, perPassWait, progressCb)
	maxPasses, perPassWait = maxPasses or 4, perPassWait or 1.2
	local collected = 0
	for pass=1,maxPasses do
		local skulls = RR.findRealSkulls()
		if progressCb then progressCb(("Ronda %d: %d skulls"):format(pass,#skulls)) end
		if #skulls==0 then if pass==1 then RunService.Heartbeat:Wait() else break end end
		for _,s in ipairs(skulls) do
			if s and s.Parent then
				RR.touchModel(s); collected+=1
				RunService.Heartbeat:Wait()
				if progressCb then progressCb(nil,collected) end
			end
		end
		task.wait(perPassWait)
	end
	return collected
end

function RR.exit()
	local door = RR.findExitDoor()
	if not door then say("RuinRush: no veo ExitDoor aÃºn."); return false end
	RR.sweepThrough(door); return true
end

function RR.runAuto(onStep,onProgress)
	RR.safeOn(); task.wait(2)
	if onStep then onStep("start") end
	RR.ensureChaseStarted(6)
	if onStep then onStep("collect") end
	local got = RR.collectAll(5,1.2,onProgress)
	if got>0 then say(("RuinRush: %d skulls recogidas."):format(got)) end
	if onStep then onStep("exit") end
	RR.exit(); RR.safeOff(); if onStep then onStep("done") end
end

UIS.InputBegan:Connect(function(input,gp)
	if gp then return end
	if input.KeyCode==Enum.KeyCode.G then RR.safeOn(); local n=RR.collectAll(5,1.2); RR.safeOff(); say("RuinRush G: "..(n or 0).." skulls") end
	if input.KeyCode==Enum.KeyCode.K then RR.safeOn(); RR.exit(); RR.safeOff() end
end)

-- =============================================================================
--                                   UI (Roact)
-- =============================================================================
if not Roact then
	say("Falta Roact: el Hub visual no se montarÃ¡ (la lÃ³gica TP/RR funciona).")
	return
end

-- Panel Teleports
local TeleportsPanel = Roact.Component:extend("TeleportsPanel")
function TeleportsPanel:init() self.state = { open=false, selectedIndex=1, status="Listo" } end
function TeleportsPanel:setOpen(o) self:setState({open=o}) end
function TeleportsPanel:select(i) self:setState({selectedIndex=i, open=false}) end
function TeleportsPanel:enterNow()
	local key = TELEPORT_OPTIONS[self.state.selectedIndex]
	self:setState({status="Cambiandoâ€¦"})
	task.spawn(function() Tele.gotoDoorWithReturn(key); task.wait(0.1); self:setState({status="Listo"}) end)
end
function TeleportsPanel:render()
	local s = self.state
	local hDrop = s.open and math.min(#TELEPORT_OPTIONS*28, 180) or 0
	local function nice(s) local i=string.find(s,"/"); return i and string.sub(s,1,i-1) or s end
	local selectedText = nice(TELEPORT_OPTIONS[s.selectedIndex] or "?")

	local dropChildren = { Layout=Roact.createElement("UIListLayout",{Padding=UDim.new(0,2)}) }
	for i,opt in ipairs(TELEPORT_OPTIONS) do
		dropChildren["opt_"..i] = Roact.createElement("TextButton",{
			Text=nice(opt), Font=Enum.Font.Gotham, TextSize=16,
			BackgroundColor3 = (i==s.selectedIndex) and Color3.fromRGB(70,120,200) or Color3.fromRGB(55,55,55),
			TextColor3=Color3.new(1,1,1), BorderSizePixel=0, Size=UDim2.new(1,-6,0,26),
			[Roact.Event.Activated]=function() self:select(i) end
		},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)})})
	end

	return Roact.createElement("Frame",{BackgroundTransparency=1,Size=UDim2.new(1,0,1,0)},{
		List = Roact.createElement("UIListLayout",{Padding=UDim.new(0,10)}),
		Title = Roact.createElement("TextLabel",{Text="Teleports (vuelve por su MainDoor)",Font=Enum.Font.GothamBold,TextSize=20,BackgroundTransparency=1,TextColor3=Color3.new(1,1,1),Size=UDim2.new(1,0,0,24)}),

		Row = Roact.createElement("Frame",{BackgroundTransparency=1,Size=UDim2.new(1,0,0,40)},{
			H = Roact.createElement("UIListLayout",{FillDirection=Enum.FillDirection.Horizontal,Padding=UDim.new(0,8)}),
			Field = Roact.createElement("TextButton",{
				Text="Destino: "..selectedText, Font=Enum.Font.GothamBold, TextSize=18,
				BackgroundColor3=Color3.fromRGB(55,55,55), TextColor3=Color3.new(1,1,1), BorderSizePixel=0,
				Size=UDim2.new(1,-160,1,0),
				[Roact.Event.Activated]=function() self:setOpen(not s.open) end
			},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)})}),
			Go = Roact.createElement("TextButton",{
				Text="ðŸŒ€ Cambiar", Font=Enum.Font.GothamBold, TextSize=18,
				BackgroundColor3=Color3.fromRGB(120,90,200), TextColor3=Color3.new(1,1,1), BorderSizePixel=0,
				Size=UDim2.new(0,150,1,0),
				[Roact.Event.Activated]=function() self:enterNow() end
			},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)})}),
		}),

		Drop = Roact.createElement("Frame",{BackgroundColor3=Color3.fromRGB(40,40,40),BorderSizePixel=0,ClipsDescendants=true,Size=UDim2.new(1,0,0,hDrop)},{
			UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)}),
			List=Roact.createElement("ScrollingFrame",{BackgroundTransparency=1,BorderSizePixel=0,CanvasSize=UDim2.new(0,0,0,#TELEPORT_OPTIONS*28),ScrollBarThickness=6,Size=UDim2.new(1,0,1,0)}, dropChildren)
		}),

		Status = Roact.createElement("TextLabel",{Text=("Estado: %s"):format(s.status),Font=Enum.Font.Gotham,TextSize=16,BackgroundTransparency=1,TextColor3=Color3.fromRGB(220,220,220),Size=UDim2.new(1,0,0,18)}),
	})
end

-- Panel RuinRush (igual 1.0)
local RRPanel = Roact.Component:extend("RRPanel")
function RRPanel:init()
	self.state = { running=false, step="idle", status="Listo", progress=0, collected=0, timer=0, log={} }
	self.timer = RunService.Heartbeat:Connect(function(dt) if self.state.running then self:setState({timer=self.state.timer+dt}) end end)
end
function RRPanel:willUnmount() if self.timer then self.timer:Disconnect() end end
function RRPanel:pushLog(t) local copy=table.clone(self.state.log); table.insert(copy,1,t); if #copy>7 then copy[#copy]=nil end; self:setState({log=copy}) end
function RRPanel:run()
	if self.state.running then return end
	self:setState({running=true, step="start", status="Iniciandoâ€¦", timer=0, collected=0, progress=0}); self:pushLog("â–¶ Auto Run")
	task.spawn(function()
		local function onStep(st)
			if     st=="start"   then self:setState({step="start",   status="Activando pedestalâ€¦"}); self:pushLog("Pedestalâ€¦")
			elseif st=="collect" then self:setState({step="collect", status="Recogiendo skullsâ€¦"}); self:pushLog("Skullsâ€¦")
			elseif st=="exit"    then self:setState({step="exit",    status="Saliendoâ€¦"});         self:pushLog("Salidaâ€¦")
			elseif st=="done"    then self:setState({step="done",    status="Hecho!"});            self:pushLog("âœ” Terminado")
			end
		end
		local function onProg(_,c) if c then self:setState({collected=c, progress=math.clamp(c/3,0,1)}) end end
		RR.runAuto(onStep,onProg)
		self:setState({running=false, status="Listo"})
	end)
end
function RRPanel:collectOnly()
	if self.state.running then return end
	self:setState({running=true, step="collect", status="Recogiendoâ€¦", timer=0, collected=0, progress=0}); self:pushLog("â–¶ Solo Skulls")
	task.spawn(function()
		RR.safeOn()
		local n = RR.collectAll(5,1.2,function(_,c) if c then self:setState({collected=c,progress=math.clamp(c/3,0,1)}) end end)
		RR.safeOff()
		self:pushLog("Skulls: "..tostring(n)); self:setState({running=false, status="Listo"})
	end)
end
function RRPanel:exitOnly()
	if self.state.running then return end
	self:setState({running=true, step="exit", status="Saliendoâ€¦", timer=0}); self:pushLog("â–¶ Salir")
	task.spawn(function() RR.safeOn(); RR.exit(); RR.safeOff(); self:setState({running=false, status="Listo"}) end)
end
function RRPanel:render()
	local s=self.state
	return Roact.createElement("Frame",{BackgroundTransparency=1,Size=UDim2.new(1,0,1,0)},{
		UIList = Roact.createElement("UIListLayout",{Padding=UDim.new(0,10)}),

		Title = Roact.createElement("TextLabel",{Text="Temple Trek â€¢ RuinRush",Font=Enum.Font.GothamBold,TextSize=20,BackgroundTransparency=1,TextColor3=Color3.new(1,1,1),Size=UDim2.new(1,0,0,24)}),

		Btns = Roact.createElement("Frame",{BackgroundTransparency=1,Size=UDim2.new(1,0,0,40)},{
			H = Roact.createElement("UIListLayout",{FillDirection=Enum.FillDirection.Horizontal,Padding=UDim.new(0,8)}),
			B1 = Roact.createElement("TextButton",{Text=s.running and ("Ejecutandoâ€¦ "..formatClock(s.timer)) or "â–¶ Auto Run",Font=Enum.Font.GothamBold,TextSize=18,BackgroundColor3=s.running and Color3.fromRGB(80,80,120) or Color3.fromRGB(70,120,200),TextColor3=Color3.new(1,1,1),BorderSizePixel=0,Size=UDim2.new(0.34,-5,1,0),[Roact.Event.Activated]=function() self:run() end},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)})}),
			B2 = Roact.createElement("TextButton",{Text="ðŸ’Ž Solo Skulls (G)",Font=Enum.Font.GothamBold,TextSize=18,BackgroundColor3=Color3.fromRGB(80,150,90),TextColor3=Color3.new(1,1,1),BorderSizePixel=0,Size=UDim2.new(0.33,-5,1,0),[Roact.Event.Activated]=function() self:collectOnly() end},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)})}),
			B3 = Roact.createElement("TextButton",{Text="ðŸšª Salir (K)",Font=Enum.Font.GothamBold,TextSize=18,BackgroundColor3=Color3.fromRGB(180,60,60),TextColor3=Color3.new(1,1,1),BorderSizePixel=0,Size=UDim2.new(0.33,0,1,0),[Roact.Event.Activated]=function() self:exitOnly() end},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)})}),
		}),

		ProgBG = Roact.createElement("Frame",{BackgroundColor3=Color3.fromRGB(50,50,50),BorderSizePixel=0,Size=UDim2.new(1,0,0,14)},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,4)}),Fill=Roact.createElement("Frame",{Size=UDim2.new(s.progress,0,1,0),BackgroundColor3=Color3.fromRGB(80,200,100),BorderSizePixel=0},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,4)})})}),
		Status = Roact.createElement("TextLabel",{Text=("Estado: %s"):format(s.status),Font=Enum.Font.Gotham,TextSize=16,BackgroundTransparency=1,TextColor3=Color3.fromRGB(220,220,220),Size=UDim2.new(1,0,0,18)}),

		LogBox = Roact.createElement("Frame",{BackgroundColor3=Color3.fromRGB(40,40,40),BorderSizePixel=0,Size=UDim2.new(1,0,1,-96)},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)}),Pad=Roact.createElement("UIPadding",{PaddingTop=UDim.new(0,8),PaddingLeft=UDim.new(0,8)}),List=Roact.createElement("UIListLayout",{Padding=UDim.new(0,6)}),
			L1=Roact.createElement("TextLabel",{Text=s.log[1] or "",Font=Enum.Font.Gotham,TextSize=15,BackgroundTransparency=1,TextColor3=Color3.new(1,1,1),Size=UDim2.new(1,-16,0,18)}),
			L2=Roact.createElement("TextLabel",{Text=s.log[2] or "",Font=Enum.Font.Gotham,TextSize=15,BackgroundTransparency=1,TextColor3=Color3.fromRGB(200,200,200),Size=UDim2.new(1,-16,0,18)}),
			L3=Roact.createElement("TextLabel",{Text=s.log[3] or "",Font=Enum.Font.Gotham,TextSize=15,BackgroundTransparency=1,TextColor3=Color3.fromRGB(180,180,180),Size=UDim2.new(1,-16,0,18)}),
			L4=Roact.createElement("TextLabel",{Text=s.log[4] or "",Font=Enum.Font.Gotham,TextSize=15,BackgroundTransparency=1,TextColor3=Color3.fromRGB(160,160,160),Size=UDim2.new(1,-16,0,18)}),
		})
	})
end

-- HUB raÃ­z
local Hub = Roact.Component:extend("MinigamesHub")
function Hub:init()
	self.state = { showUI=true, pos=UDim2.new(0.5,-380,0.55,-200), dragging=false, dragOffset=Vector2.zero, antiAFK=false, active="RuinRush" }
end
function Hub:willUnmount() if self.afkConn then self.afkConn:Disconnect() end end
function Hub:startDrag(io) self:setState({dragging=true,dragOffset=(io.Position-Vector3.new(self.ref.AbsolutePosition.X,self.ref.AbsolutePosition.Y,0)).XY}) end
function Hub:doDrag(io) if self.state.dragging then local np=(io.Position-Vector3.new(0,0,0)).XY-self.state.dragOffset; self:setState({pos=UDim2.new(0,np.X,0,np.Y)}) end end
function Hub:stopDrag() self:setState({dragging=false}) end
function Hub:toggleAntiAFK()
	if not self.state.antiAFK then
		self.afkConn = Players.LocalPlayer.Idled:Connect(function() VU:CaptureController(); VU:ClickButton2(Vector2.zero) end)
	else
		if self.afkConn then self.afkConn:Disconnect(); self.afkConn=nil end
	end
	self:setState({antiAFK=not self.state.antiAFK})
end

local MINIGAMES = {
	{ id="RuinRush",  title="RuinRush",  Component=RRPanel },
	{ id="Teleports", title="Teleports", Component=TeleportsPanel },
}

function Hub:render()
	local s=self.state
	local sideChildren={ Layout=Roact.createElement("UIListLayout",{Padding=UDim.new(0,6)}) }
	for _,mg in ipairs(MINIGAMES) do
		sideChildren["btn_"..mg.id]=Roact.createElement("TextButton",{
			Text=(s.active==mg.id and "â–¶ " or "")..mg.title, Font=Enum.Font.GothamBold, TextSize=16,
			BackgroundColor3=(s.active==mg.id) and Color3.fromRGB(70,120,200) or Color3.fromRGB(55,55,55),
			TextColor3=Color3.new(1,1,1), BorderSizePixel=0, Size=UDim2.new(1,0,0,36),
			[Roact.Event.Activated]=function() self:setState({active=mg.id}) end
		},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)})})
	end
	local contentChildren={ Layout=Roact.createElement("UIListLayout",{Padding=UDim.new(0,0)}) }
	for _,mg in ipairs(MINIGAMES) do
		contentChildren["panel_"..mg.id]=Roact.createElement("Frame",{Visible=(s.active==mg.id),BackgroundTransparency=1,Size=UDim2.new(1,0,1,0)},{ Panel=Roact.createElement(mg.Component) })
	end

	return Roact.createElement("ScreenGui",{ResetOnSpawn=false},{
		Toggle=Roact.createElement("TextButton",{Text=":D",Font=Enum.Font.GothamBold,TextSize=22,BackgroundColor3=Color3.fromRGB(50,50,90),TextColor3=Color3.new(1,1,1),Size=UDim2.new(0,36,0,36),Position=UDim2.new(0,10,0,10),ZIndex=5,[Roact.Event.Activated]=function() self:setState({showUI=not s.showUI}) end}),
		Main=Roact.createElement("Frame",{
			Visible=s.showUI, Size=UDim2.new(0,760,0,400), Position=s.pos,
			BackgroundColor3=Color3.fromRGB(30,30,30), BorderSizePixel=0,
			[Roact.Ref]=function(r) self.ref=r end,
			[Roact.Event.InputBegan]=function(_,io) if io.UserInputType==Enum.UserInputType.MouseButton1 then self:startDrag(io) end end,
			[Roact.Event.InputChanged]=function(_,io) if io.UserInputType==Enum.UserInputType.MouseMovement then self:doDrag(io) end end,
			[Roact.Event.InputEnded]=function(_,io) if io.UserInputType==Enum.UserInputType.MouseButton1 then self:stopDrag() end end,
		},{
			UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,10)}),
			Header=Roact.createElement("Frame",{BackgroundTransparency=1,Size=UDim2.new(1,0,0,48)},{
				Title=Roact.createElement("TextLabel",{Text="Minigames Hub",Font=Enum.Font.GothamBold,TextSize=20,BackgroundTransparency=1,TextColor3=Color3.new(1,1,1),Size=UDim2.new(0.6,0,1,0),Position=UDim2.new(0,14,0,0),TextXAlignment=Enum.TextXAlignment.Left}),
				Anti=Roact.createElement("TextButton",{Text=s.antiAFK and "ðŸŸ¢ Anti-AFK ON" or "âšª Anti-AFK",Font=Enum.Font.GothamBold,TextSize=16,BackgroundColor3=s.antiAFK and Color3.fromRGB(60,120,60) or Color3.fromRGB(70,70,70),TextColor3=Color3.new(1,1,1),BorderSizePixel=0,Size=UDim2.new(0,160,0,32),Position=UDim2.new(1,-174,0,8),[Roact.Event.Activated]=function() self:toggleAntiAFK() end},{UIC=Roact.createElement("UICorner",{CornerRadius=UDim.new(0,6)})}),
			}),
			Sep=Roact.createElement("Frame",{BackgroundColor3=Color3.fromRGB(55,55,55),BorderSizePixel=0,Size=UDim2.new(1,-20,0,1),Position=UDim2.new(0,10,0,48)}),
			Body=Roact.createElement("Frame",{BackgroundTransparency=1,Size=UDim2.new(1,-20,1,-62),Position=UDim2.new(0,10,0,58)},{
				Layout=Roact.createElement("UIListLayout",{FillDirection=Enum.FillDirection.Horizontal,Padding=UDim.new(0,10)}),
				Side=Roact.createElement("Frame",{BackgroundColor3=Color3.fromRGB(35,35,35),BorderSizePixel=0,Size=UDim2.new(0,190,1,0)},sideChildren),
				Content=Roact.createElement("Frame",{BackgroundTransparency=1,Size=UDim2.new(1,-200,1,0)},contentChildren),
			})
		})
	})
end

Roact.mount(Roact.createElement(Hub), LP:WaitForChild("PlayerGui"))
