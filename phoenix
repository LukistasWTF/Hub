-- L1 seguro (sin llamadas)
local __L1_OK__ = true

-- ===== Safe wrappers (por si pcall/task est√°n ensombrecidos) =====
local _pcall = rawget(_G, "pcall")
local SAFE_PCALL = (type(_pcall)=="function") and function(fn, ...) return _pcall(fn, ...) end or function(fn, ...) return true, fn(...) end
local SAFE_SPAWN = (task and task.spawn) or function(f, ...) coroutine.resume(coroutine.create(f), ...) end

-- ===== Servicios / jugador =====
local RS = game:GetService("ReplicatedStorage")
local RF = game:GetService("ReplicatedFirst")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
if not RunService:IsClient() then return end
local LP = Players.LocalPlayer
if not LP then return end

-- ===== Logs =====
local function LOG(tag, ...) print(string.format("%s %s", tag, os.date("!%H:%M:%S")), ...) end
local function logI(...) LOG("üü¢ [v12.2]", ...) end
local function logW(...) LOG("‚ö†Ô∏è  [v12.2]", ...) end
local function logS(...) LOG("‚úÖ [v12.2]", ...) end

-- =================================================================
-- A) HOTPATCH: ReplicatedFirst.Load.LoadTimers.name_from_source (fix nil cat)
-- =================================================================
local function hotpatch_LoadTimers()
    local loadFolder = RF:FindFirstChild("Load")
    local ms = loadFolder and loadFolder:FindFirstChild("LoadTimers")
    if not (ms and ms:IsA("ModuleScript")) then
        logW("LoadTimers no encontrado; salto hotpatch.")
        return
    end
    local ok, LT = SAFE_PCALL(function() return require(ms) end)
    if not ok or type(LT)~="table" then
        logW("No se pudo require LoadTimers; salto hotpatch.")
        return
    end
    local old = LT.name_from_source
    LT.name_from_source = function(src)
        local full = "?"
        local ok1, res = SAFE_PCALL(function()
            if typeof(src)=="Instance" then
                return src:GetFullName()
            else
                return tostring(src)
            end
        end)
        if ok1 and res then full = res end
        if type(old)=="function" then
            local ok2, ret = SAFE_PCALL(old, src)
            if ok2 and ret ~= nil then
                -- si el viejo ya funciona, √∫salo; si devuelve nil, usa fallback
                return ret
            end
        end
        return full
    end
    logS("Hotpatch LoadTimers.name_from_source aplicado.")
end
hotpatch_LoadTimers()

-- =================================================================
-- B) Loader Fsys robusto (igual al que te funcion√≥) + fallback seguro
-- =================================================================
local FsysModule = RS:FindFirstChild("Fsys")
local FsysLoad
if FsysModule and FsysModule:IsA("ModuleScript") then
    local ok, mod = SAFE_PCALL(function() return require(FsysModule) end)
    if ok and type(mod)=="table" and type(mod.load)=="function" then
        FsysLoad = mod.load
        logS("Fsys.load activo.")
    else
        logW("Fsys presente pero sin .load usable; usar√© fallback.")
    end
else
    logW("Fsys no encontrado como ModuleScript; usar√© fallback.")
end

local function srequire(ms)
    if typeof(ms)=="Instance" and ms:IsA("ModuleScript") then
        local ok, ret = SAFE_PCALL(function() return require(ms) end)
        if ok then return ret end
    end
    return nil
end

local function findModuleByPath(path)
    if type(path)~="string" or path=="" then return nil end
    local segs = {}
    for seg in string.gmatch(path, "[^/]+") do segs[#segs+1]=seg end
    if #segs>0 then
        local node = RS
        for i=1,#segs do node = node and node:FindFirstChild(segs[i]) end
        if node and node:IsA("ModuleScript") then return node end
    end
    local last = segs[#segs] or path
    for _,d in ipairs(RS:GetDescendants()) do
        if d:IsA("ModuleScript") and d.Name==last then return d end
    end
    return nil
end

local function loadM(name)
    if type(name)~="string" then return nil end
    if string.find(name, "new:") == 1 then
        logW("Ignorando alias especial:", name)
        return nil
    end
    if FsysLoad then
        local ok, ret = SAFE_PCALL(function() return FsysLoad(name) end)
        if ok and ret ~= nil then
            logI("M√≥dulo via Fsys:", name)
            return ret
        end
        logW("Fsys.load no pudo cargar '"..name.."', intento fallback.")
    end
    local ms = findModuleByPath(name)
    if ms then
        local got = srequire(ms)
        if got ~= nil then
            logI("M√≥dulo por b√∫squeda:", name, "‚Üê", ms:GetFullName())
            return got
        end
    end
    logW("No se pudo cargar m√≥dulo:", name)
    return nil
end

-- =================================================================
-- C) AutoMinigames v12.2 (cola inteligente + TP + FULL autoplay)
-- =================================================================
local CONFIG = {
    autoEnabled           = true,
    statusRefresh         = 1.0,
    defaultQueueCountdown = 12,
    inProgressGrace       = 5,
    coords = {
        joetation    = Vector3.new(-590.8, 35.8, -1667.1),
        coconut_bonk = Vector3.new(-600.3, 41.6, -1610.3),
    },
    sendJoinMessageAfterTP = false,
    actionCadence = { joetation = 0.85, coconut_bonk = 0.80 },
    minCadence = 0.45, maxCadence = 2.00, stepDown = 0.06, stepUp = 0.10,
    joetation = { triesPerAct = 5, fallbackMaxIdx = 14 },
    coconut   = { pilesToCycle = 5, usesPerAct = 5 },
    burstThreshold = 7, burstMultiplier = 2,
    enableAFK = true, verboseRPC = true,
}

local LiveOpsTime           = loadM("LiveOpsTime") or { now=function() return os.clock() end }
local MinigameClientManager = loadM("MinigameClientManager")
local ClientData            = loadM("ClientData")

local function nowS() return LiveOpsTime.now() end
local function srvNow() if typeof(workspace.GetServerTimeNow)=="function" then return workspace:GetServerTimeNow() end return nowS() end
local function hrp() local c=LP.Character; return c and c:FindFirstChild("HumanoidRootPart") end
local function fmtTime(s) s=math.max(0, math.floor(s)); return string.format("%02d:%02d", math.floor(s/60), s%60) end

local function getRoot()
    local char = LP.Character or LP.CharacterAdded:Wait()
    return char:WaitForChild("HumanoidRootPart"), char:WaitForChild("Humanoid")
end
local function tpTo(v3)
    if typeof(v3)~="Vector3" then return end
    local root, hum = getRoot(); if not root or not hum then return end
    if workspace.StreamingEnabled and typeof(LP.RequestStreamAroundAsync)=="function" then
        SAFE_PCALL(function() LP:RequestStreamAroundAsync(v3, 128) end)
    end
    local oldState; SAFE_PCALL(function() oldState=hum:GetState(); hum:ChangeState(Enum.HumanoidStateType.Physics) end)
    local look = (root.CFrame * CFrame.new(0,0,-1)).Position
    root.CFrame = CFrame.new(v3 + Vector3.new(0,3,0), look)
    task.delay(0.12, function() if hum and hum.Parent then SAFE_PCALL(function() if oldState then hum:ChangeState(oldState) end end) end)
end

local function refreshMgr()
    if not MinigameClientManager then MinigameClientManager = loadM("MinigameClientManager") end
    return MinigameClientManager
end
local function getClient(id)
    if not refreshMgr() or typeof(MinigameClientManager.get)~="function" then return nil end
    local ok, cli = SAFE_PCALL(function() return MinigameClientManager.get(id) end)
    return ok and cli or nil
end

local function readStatus(cli)
    local st = { active=false, loading=false, inQueue=false, timeLeft=nil, raw=nil }
    local ms = cli and cli.minigame_state
    local now = srvNow()
    if ms then
        local get = (typeof(ms.get)=="function") and function(k) local ok,v=SAFE_PCALL(function() return ms:get(k) end); return ok and v or nil end or function() return nil end
        st.active  = get("is_game_active") or false
        st.loading = get("players_loading") or false
        if typeof(ms.get_as_table)=="function" then
            local t; SAFE_PCALL(function() t = ms:get_as_table("queued_user_ids") end)
            if type(t)=="table" then for _,uid in ipairs(t) do if uid==LP.UserId then st.inQueue=true break end end end
        end
        local zts = get("zone_override_timestamp")
        if typeof(zts)=="number" and zts>0 then
            st.timeLeft = math.max(0, math.floor(zts - now)); st.raw="zone_override_timestamp"
        end
    end
    if cli and cli.is_participating and cli.end_time then
        st.active = true
        st.timeLeft = math.max(0, math.floor(cli.end_time - now))
        st.raw = st.raw or "client.end_time"
    end
    if (not st.timeLeft) and ClientData and cli and cli.cycle_timestamp_key and typeof(ClientData.get)=="function" then
        SAFE_PCALL(function()
            local rec = ClientData.get(cli.cycle_timestamp_key)
            local ts = rec and (rec.timestamp or rec.t or rec.next_timestamp)
            if ts then st.timeLeft = math.max(0, math.floor(ts - now)); st.raw="ClientData.cycle_timestamp" end
        end)
    end
    return st
end

local function etaToStart(cli, st)
    if st.active then return (st.timeLeft or CONFIG.defaultQueueCountdown)+CONFIG.inProgressGrace, false, st.raw end
    if st.loading then return 5, true, "players_loading" end
    if st.timeLeft and st.timeLeft>0 then return st.timeLeft, true, st.raw end
    return CONFIG.defaultQueueCountdown, true, "fallback"
end

local function statusAndEta(id)
    local cli = getClient(id); if not cli then return nil end
    local st = readStatus(cli)
    local eta, joinable, raw = etaToStart(cli, st)
    return { id=id, cli=cli, st=st, eta=eta, joinable=joinable, raw=raw }
end

local ORDER = { "joetation", "coconut_bonk" }
local function pickBest()
    local best, bestEta
    for _,id in ipairs(ORDER) do
        local r = statusAndEta(id)
        if r then
            logI(string.format("üì° ETA %-13s ‚Üí ‚è± %s (%s) active=%s inQueue=%s", id, fmtTime(r.eta), r.raw or "fallback", tostring(r.st.active), tostring(r.st.inQueue)))
            if r.eta < (bestEta or math.huge) then best,bestEta = id, r.eta end
        else
            logW("üì° ETA "..id.." ‚Üí sin datos")
        end
    end
    return best or "joetation"
end

local dynCad, lastAct = {}, {}
for k,v in pairs(CONFIG.actionCadence) do dynCad[k]=v end
local function canAct(id) local cad=dynCad[id] or 1.0; local t=nowS(); if not lastAct[id] or (t-lastAct[id])>=cad then lastAct[id]=t; return true end return false end
local function tuneCad(id, ok, burst)
    local cad=dynCad[id] or 1.0
    if ok then cad=math.max(CONFIG.minCadence, cad - CONFIG.stepDown*(burst and 1.5 or 1))
    else cad=math.min(CONFIG.maxCadence, cad + CONFIG.stepUp) end
    dynCad[id]=cad
    logI(string.format("‚è≤Ô∏è Cadencia %-13s ‚Üí %.2fs (ok=%s, burst=%s)", id, cad, tostring(ok), tostring(burst)))
end
local function rpc(cli, route, ...)
    if not cli or typeof(cli.message_server)~="function" then return false end
    local ok, err = SAFE_PCALL(function() return cli:message_server(route, ...) end)
    if not ok and CONFIG.verboseRPC then logW("üì® RPC FAIL:", route, err) end
    return ok
end

local cannonCursor, shipCursor, pileIdx = 1,1,1
local function cannonList(cli)
    local arr = {}
    local ok, list = SAFE_PCALL(function() return cli.cannons_world end); list = ok and list or nil
    if type(list)=="table" and #list>0 then for i=1,#list do arr[#arr+1]=i end else for i=1,CONFIG.joetation.fallbackMaxIdx do arr[#arr+1]=i end end
    return arr
end
local function shipUidList(cli)
    local arr = {}
    local ok, map = SAFE_PCALL(function() return cli.ships_by_uid end); map = ok and map or nil
    if type(map)=="table" then for uid,_ in pairs(map) do arr[#arr+1]=uid end end
    return arr
end

local function act_joetation(cli, r)
    if not canAct("joetation") then return end
    local tleft = r and r.st and r.st.timeLeft or nil
    local burst = (tleft and tleft <= CONFIG.burstThreshold)
    local root = hrp(); local pos = root and root.Position or Vector3.new()
    rpc(cli, "pickup_holdable_from_pile", pos, nowS()); logI("üéí [joetation] pickup_holdable_from_pile")
    local list = cannonList(cli)
    local tries = CONFIG.joetation.triesPerAct * (burst and CONFIG.burstMultiplier or 1)
    local okAny = false
    for n=1, math.max(1, tries) do
        if #list==0 then break end
        local idx = list[cannonCursor]; cannonCursor = (cannonCursor % #list) + 1
        local ok = rpc(cli, "use_cannon", idx, pos, nowS())
        logI(string.format("üí• [joetation] %s %d/%d ‚Üí cannon=%d ‚Üí ok=%s", burst and "[BURST]" or "intento", n, tries, idx, tostring(ok)))
        okAny = okAny or ok
    end
    if not okAny then logW("üí§ [joetation] sin disparo exitoso") end
    tuneCad("joetation", okAny, burst)
end

local function act_coconut(cli, r)
    if not canAct("coconut_bonk") then return end
    local tleft = r and r.st and r.st.timeLeft or nil
    local burst = (tleft and tleft <= CONFIG.burstThreshold)
    rpc(cli, "pickup_droppable", pileIdx)
    logI(string.format("üéí [coconut] pickup_droppable ‚Üí pile=%d%s", pileIdx, burst and " [BURST]" or ""))
    pileIdx = (pileIdx % CONFIG.coconut.pilesToCycle) + 1
    local uids = shipUidList(cli); if #uids==0 then logW("üõ∂ [coconut] ships_by_uid vac√≠o"); tuneCad("coconut_bonk", false, burst); return end
    local uses = CONFIG.coconut.usesPerAct * (burst and CONFIG.burstMultiplier or 1)
    local okAny=false
    for n=1, math.max(1, uses) do
        if shipCursor>#uids then shipCursor=1 end
        local uid = uids[shipCursor]; shipCursor = shipCursor + 1
        local ok = rpc(cli, "used_droppable", uid)
        logI(string.format("üîß [coconut] %s %d/%d ‚Üí uid=%s ‚Üí ok=%s", burst and "[BURST]" or "intento", n, uses, tostring(uid), tostring(ok)))
        okAny = okAny or ok
    end
    if not okAny then logW("üí§ [coconut] sin uso exitoso") end
    tuneCad("coconut_bonk", okAny, burst)
end

if CONFIG.enableAFK then
    LP.Idled:Connect(function()
        local vu = game:GetService("VirtualUser")
        vu:CaptureController(); vu:ClickButton2(Vector2.new())
        logI("üñ±Ô∏è Anti‚ÄëAFK: click simulado.")
    end)
end

local function parseVec3(sx,sy,sz) local x=tonumber((sx or ""):gsub(",", ".")) or 0; local y=tonumber((sy or ""):gsub(",", ".")) or 0; local z=tonumber((sz or ""):gsub(",", ".")) or 0; return Vector3.new(x,y,z) end
LP.Chatted:Connect(function(msg)
    msg = msg or ""
    local args = {}; for w in msg:gmatch("%S+") do args[#args+1]=w end
    if args[1]=="/auto" and args[2] then
        if args[2]:lower()=="on" then logS("üü¢ AUTO ON"); CONFIG.autoEnabled=true elseif args[2]:lower()=="off" then logS("üî¥ AUTO OFF"); CONFIG.autoEnabled=false end
    elseif args[1]=="/coords" and args[2] and args[3] and args[4] and args[5] then
        local id=args[2]; if CONFIG.coords[id] then CONFIG.coords[id]=parseVec3(args[3],args[4],args[5]); local v=CONFIG.coords[id]; logS(string.format("üìç %s = (%.1f, %.1f, %.1f)", id, v.X, v.Y, v.Z)) else logW("Uso: /coords joetation|coconut_bonk X Y Z") end
    elseif args[1]=="/tp" and args[2] and CONFIG.coords[args[2]] then tpTo(CONFIG.coords[args[2]]); logS("üß≠ TP manual ‚Üí "..args[2]) end
end)

SAFE_SPAWN(function()
    logI("‚ú® AutoMinigames listo. AUTO =", CONFIG.autoEnabled and "ON" or "OFF")
    local currentPlaying
    while true do
        if CONFIG.autoEnabled then
            local anyPlaying, playingId = false, nil
            for _, id in ipairs(ORDER) do
                local r = statusAndEta(id)
                if r and r.cli and r.cli.is_participating then anyPlaying=true; playingId=id end
            end
            if not anyPlaying then
                local best = pickBest()
                if currentPlaying ~= nil then logS("üèÅ Partida anterior finalizada.") end
                currentPlaying = nil
                local target = CONFIG.coords[best] or CONFIG.coords.joetation
                logI(string.format("üß≠ TP ‚Üí %-13s @ (%.1f, %.1f, %.1f)", best, target.X, target.Y, target.Z))
                tpTo(target)
                if CONFIG.sendJoinMessageAfterTP then
                    local r = statusAndEta(best); if r and r.cli then SAFE_PCALL(function() r.cli:message_server("join_queue") end) end
                    logI("üì® join_queue (opcional) enviado.")
                end
                task.wait(2)
            else
                if currentPlaying ~= playingId then currentPlaying=playingId; cannonCursor,shipCursor,pileIdx=1,1,1; logS("üéÆ Entraste a "..currentPlaying.." (FULL)") end
                local r = statusAndEta(currentPlaying)
                if r and r.cli and r.cli.is_participating then
                    if currentPlaying=="joetation" then act_joetation(r.cli, r) else act_coconut(r.cli, r) end
                end
                task.wait(0.1)
            end
        else
            task.wait(0.25)
        end
        task.wait(CONFIG.statusRefresh)
    end
end)
